---
description:
globs:
alwaysApply: false
---
# 实体属性编辑器设计文档

## 🎯 核心问题解决方案

### 问题背景
- React组件中使用可变属性作为key导致input失去焦点
- 用户修改属性名时，组件重新渲染，编辑状态丢失
- 数据结构过于复杂，维护困难

### 解决方案：nanoid索引设计模式

## 📊 数据结构设计

### 1. Store数据结构 (后台交互)
```javascript
// 存储在 [entity-store](mdc:apps/demo-free-layout-forked/src/components/ext/entity-store/index.tsx) 中
{
  id: "helicopter",
  name: "直升机",
  bundles: ["container", "mobile", "controlled"], // 完整关联的模块
  attributes: [
    { id: "vehicle_yard_id", name: "集结点id", type: "s", enumClassId: "yard_enum" },
    { id: "task_id", name: "任务id", type: "s" }
  ]
}
```

### 2. JSONSchema数据结构 (节点编辑器)
```javascript
// 在 [entity-properties-editor](mdc:apps/demo-free-layout-forked/src/components/ext/entity-properties-editor/index.tsx) 中处理
{
  type: "object",
  properties: {
    "abc123": {                    // nanoid作为key - React key专用
      id: "vehicle_yard_id",       // 原始英文标识符
      name: "集结点id",            // 原始中文名称
      type: "string",              // 转换后的JSONSchema类型
      description: "...",          // 描述信息
      enumClassId: "yard_enum",    // 保留的meta属性
      _id: "abc123",               // 索引ID - 与key相同
      isEntityProperty: true       // 属性分类标记
    },
    "def456": {                    // nanoid作为key
      id: "mobile/path",           // 模块属性ID格式
      name: "路径",                // 原始中文名称
      type: "array",
      items: { type: "string" },
      description: "来自模块: 移动的",
      _id: "def456",               // 索引ID
      isModuleProperty: true,      // 模块属性标记
      moduleId: "mobile"           // 所属模块ID
    }
  }
}
```

## 🔑 nanoid索引设计核心

### 索引ID (nanoid)
- **用途**: React key专用，确保组件稳定性
- **特点**: 永远不变，使用nanoid生成
- **生成**: `nanoid()` - 短小精悍的唯一标识符
- **使用**: 作为properties的key和_id字段

### Meta属性保留
- **原则**: 使用`...attr`保留所有原始Attribute属性
- **包含**: id, name, type, description, enumClassId等所有字段
- **覆盖**: 只覆盖需要转换的字段（如type转换为JSONSchema格式）

## 🔄 属性分类逻辑

### 1. 实体直接属性
- **来源**: `entity.attributes`
- **标记**: `isEntityProperty: true`
- **可编辑**: 是

### 2. 完整关联模块属性
- **来源**: `entity.bundles` 中的模块
- **标记**: `isModuleProperty: true`
- **ID格式**: `moduleId/attrId`
- **可编辑**: 否 (只读)

### 3. 部分关联模块属性
- **来源**: 单独添加的模块属性
- **标记**: `isModuleProperty: true`
- **可编辑**: 是 (可删除)

### 4. 用户自定义属性
- **来源**: 用户手动添加
- **标记**: 无特殊标记
- **可编辑**: 是

## 🛠️ 实现要点

### React Key使用
```javascript
// ✅ 正确 - 使用稳定的nanoid
<PropertyEdit key={nanoidKey} />

// ❌ 错误 - 使用可变的语义化ID
<PropertyEdit key={property.title} />
```

### 属性编辑逻辑
```javascript
// 编辑属性名时，只修改name，不动nanoid key
const handleEditProperty = (nanoidKey, updatedFields) => {
  // nanoidKey 是 properties的key (nanoid)
  // updatedFields.name 是新的显示名称
  // nanoid key 永远不变，确保React组件稳定
}
```

### 数据持久化
- nanoid存储在 properties的key和`_id` 字段中
- 重新加载时从 `_id` 恢复，确保React key稳定
- 如果没有 `_id`，生成新的nanoid

## 📋 表格组件设计模式

### 双表格设计
- **节点表格**：只读显示，简单文本渲染
- **抽屉表格**：可编辑，Input组件渲染
- **共享数据源**：使用相同的数据结构，不同的展示逻辑

### Semi Design Table最佳实践
```javascript
// ✅ 正确的数据结构设计
{
  title: '',
  dataIndex: 'id',          // 对应数据字段
  key: 'id',               // 唯一标识
  render: (text, record) => {
    // text 是 dataSource[i][dataIndex] 的值
    // 优先使用 text，它是Semi Design自动传递的正确值
    return <Input value={text} />
  }
}

// ❌ 错误的做法
render: (text, record) => {
  // 忽略text，只依赖record可能导致显示问题
  return <Input value={record.someField} />
}
```

### 可展开表格的缩进问题
```javascript
// 问题：可展开表格第一列会自动添加缩进，导致内容显示异常
// 解决方案1：专门的展开列
columns = [
  {
    title: '',
    dataIndex: 'expand',
    key: 'expand',
    width: 30,
    render: () => null, // 展开按钮由Table自动处理
  },
  // 其他内容列不受缩进影响
]

// 解决方案2：禁用缩进
<Table indentSize={0} />
```

### 模块属性的前缀处理
```javascript
// 显示时去掉模块前缀
const displayValue = record.displayId || text; // container/content -> content

// 编辑时重新组装完整ID
onChange={(value) => {
  if (record.category === 'module' && record.moduleId) {
    const fullId = `${record.moduleId}/${value}`; // content -> container/content
    onPropertyChange(record.key, 'id', fullId);
  }
}}
```

## 🚫 避免的反模式

1. **不要用属性内容作为React key**
   ```javascript
   // ❌ 错误
   key={`entity_${attr.id}`}
   key={`custom_${propertyName}`}
   ```

2. **不要在编辑时重新生成nanoid**
   ```javascript
   // ❌ 错误 - 每次编辑都生成新nanoid
   _id: nanoid()
   ```

3. **不要隐藏meta属性**
   ```javascript
   // ❌ 错误 - 只保留部分属性
   { type, description }

   // ✅ 正确 - 保留所有原始属性
   { ...attr, type: convertedType }
   ```

4. **不要忽略Semi Design Table的text参数**
   ```javascript
   // ❌ 错误 - 忽略text参数
   render: (text, record) => <Input value={record.name} />

   // ✅ 正确 - 优先使用text
   render: (text, record) => <Input value={text} />
   ```

## 🐛 问题诊断思路

### UI显示问题诊断顺序
1. **检查HTML结构** - 看DOM元素是否正确渲染
2. **检查CSS样式** - 确认是否有样式冲突或隐藏
3. **检查数据流** - 确认数据是否正确传递
4. **检查组件逻辑** - 最后才深入代码逻辑

### 常见问题模式
- **内容不显示**：通常是DOM结构问题，不是数据问题
- **Input失去焦点**：React key不稳定导致重新渲染
- **表格列错位**：可展开表格的缩进干扰
- **数据不更新**：引用型数据没有正确更新引用

## 📁 相关文件

- 主组件: [entity-properties-editor/index.tsx](mdc:apps/demo-free-layout-forked/src/components/ext/entity-properties-editor/index.tsx)
- 实体存储: [entity-store/index.tsx](mdc:apps/demo-free-layout-forked/src/components/ext/entity-store/index.tsx)
- 模块存储: [module-store.tsx](mdc:apps/demo-free-layout-forked/src/components/ext/entity-property-type-selector/module-store.tsx)
- 节点表格: [node-property-table.tsx](mdc:apps/demo-free-layout-forked/src/components/ext/property-table/node-property-table.tsx)
- 抽屉表格: [drawer-property-table.tsx](mdc:apps/demo-free-layout-forked/src/components/ext/property-table/drawer-property-table.tsx)
- 表格适配器: [property-table-adapter.tsx](mdc:apps/demo-free-layout-forked/src/components/ext/property-table/property-table-adapter.tsx)

## ✅ 验证标准

1. 修改属性名时input不失去焦点
2. 属性顺序保持稳定
3. 页面刷新后React key保持不变
4. 数据结构简洁清晰
5. 性能良好，无不必要的重新渲染
6. 所有meta属性都被保留和显示
7. 表格内容正确显示，无缩进干扰
8. 模块属性前缀处理正确
